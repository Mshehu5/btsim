use std::{collections::HashSet, iter::Sum, ops::Add};

use bitcoin::Amount;
use log::debug;

use crate::{
    bulletin_board::BulletinBoardId,
    message::{MessageId, PayjoinProposal},
    transaction::Outpoint,
    wallet::{PaymentObligationData, PaymentObligationId, WalletHandleMut, WalletId},
    Simulation, TimeStep,
};

fn piecewise_linear(x: f64, points: &[(f64, f64)]) -> f64 {
    assert!(points.len() >= 2, "need at least two points");

    // Clamp on either end of the points
    if x <= points[0].0 {
        return points[0].1;
    }

    let last = points.len() - 1;
    if x >= points[last].0 {
        return points[last].1;
    }

    // Find segment [x_i, x_{i+1}] containing x
    for window in points.windows(2) {
        let (x0, y0) = window[0];
        let (x1, y1) = window[1];

        if x >= x0 && x <= x1 {
            let t = (x - x0) / (x1 - x0);
            return y0 + t * (y1 - y0);
        }
    }

    unreachable!("x did not fall into any segment; are points sorted?");
}

/// An Action a wallet can perform
#[derive(Debug)]
pub(crate) enum Action {
    /// Spend a payment obligation unilaterally
    UnilateralSpend(PaymentObligationId),
    /// Batch spend multiple payment obligations
    BatchSpend(Vec<PaymentObligationId>),
    /// Initiate a payjoin with a counterparty
    InitiatePayjoin(PaymentObligationId),
    /// respond to a payjoin proposal
    RespondToPayjoin(
        PayjoinProposal,
        PaymentObligationId,
        BulletinBoardId,
        MessageId,
    ),
    InitiateMultiPartyPayjoin(Vec<PaymentObligationId>),
    /// Participate in Multiparty payjoin
    ParticipateMultiPartyPayjoin((MessageId, BulletinBoardId, PaymentObligationId)),
    /// Continue to participate in a multi-party payjoin
    ContinueParticipateMultiPartyPayjoin(BulletinBoardId),
    /// Do nothing. There may be better oppurtunities to spend a payment obligation or participate in a payjoin.
    Wait,
}

/// Hypothetical outcomes of an action
#[derive(Debug)]
pub(crate) enum PredictedOutcome {
    PaymentObligationsHandled(Vec<PaymentObligationHandledOutcome>),
    InitiatePayjoin(InitiatePayjoinOutcome),
    RespondToPayjoin(RespondToPayjoinOutcome),
    InitiateMultiPartyPayjoin(InitiateMultiPartyPayjoinOutcome),
    ParticipateMultiPartyPayjoin(ParticipateMultiPartyPayjoinOutcome),
}

#[derive(Debug)]
pub(crate) struct PaymentObligationHandledOutcome {
    /// Payment obligation amount
    amount_handled: f64,
    /// Balance difference after the action
    balance_difference: f64,
    /// Time left on the payment obligation
    time_left: i32,
}

impl PaymentObligationHandledOutcome {
    fn score(&self, payment_obligation_utility_factor: f64) -> ActionScore {
        let points = [
            (0.0, 2.0 * payment_obligation_utility_factor),
            (2.0, payment_obligation_utility_factor),
            (5.0, 0.0),
        ];
        let utility = piecewise_linear(self.time_left as f64, &points);
        let score = self.balance_difference + (self.amount_handled * utility);
        debug!("PaymentObligationHandledEvent score: {:?}", score);
        ActionScore(score)
    }
}

#[derive(Debug)]
pub(crate) struct InitiatePayjoinOutcome {
    /// Time left on the payment obligation
    time_left: i32,
    /// Amount of the payment obligation
    amount_handled: f64,
    /// Balance difference after the action
    balance_difference: f64,
    /// Fee savings from the payjoin
    fee_savings: Amount,
    // TODO: somekind of privacy gained metric?
}

impl InitiatePayjoinOutcome {
    /// Batching anxiety should increase and payjoin utility should decrease the closer the deadline is.
    /// This can be modeled as a inverse cubic function of the time left.
    /// TODO: how do we model potential fee savings? Understanding that at most there will be one input and one output added could lead to a simple linear model.
    fn score(&self, payjoin_utility_factor: f64) -> ActionScore {
        let points = [
            (0.0, 0.0),
            (2.0, payjoin_utility_factor),
            (5.0, 5.0 * payjoin_utility_factor),
        ];
        let utility = piecewise_linear(self.time_left as f64, &points);

        let score = self.balance_difference + (self.amount_handled * utility);
        debug!("InitiatePayjoinEvent score: {:?}", score);
        ActionScore(score)
    }
}

#[derive(Debug)]
pub(crate) struct RespondToPayjoinOutcome {
    /// Amount of the payment obligation
    amount_handled: f64,
    /// Balance difference after the action
    balance_difference: f64,
    /// Fee savings from the payjoin
    fee_savings: Amount,
}

impl RespondToPayjoinOutcome {
    fn score(&self, payjoin_utility_factor: f64) -> ActionScore {
        // Responding to a payjoin should always be better than unilaterally spending at this point
        // As there is no interaction cost. TODO in the future we will want to model the cost of doing the last round of interaction with the counterparty

        // Since there is no final interaction cost, we can just score the balance difference and the amount handled
        // However the utility should be higher for fee saving an a privacy preservation.
        // TODO These last two are not factored in yet.
        let score = self.balance_difference + (payjoin_utility_factor * self.amount_handled);
        debug!("RespondToPayjoinEvent score: {:?}", score);

        ActionScore(score)
    }
}

#[derive(Debug)]
pub(crate) struct InitiateMultiPartyPayjoinOutcome {
    /// Time left on the payment obligation
    time_left: i32,
    /// Amount of the payment obligation
    amount_handled: f64,
    /// Balance difference after the action
    balance_difference: f64,
    /// Upper bound on the number of participants in the multi-party payjoin
    max_participants: u32,
}

impl InitiateMultiPartyPayjoinOutcome {
    fn score(&self, multi_party_payjoin_utility_factor: f64) -> ActionScore {
        // For now the score for initiating a multi-party payjoin is really high so it always happens no matter what
        let score = self.amount_handled * 100.0;
        debug!("InitiateMultiPartyPayjoinEvent score: {:?}", score);
        ActionScore(score)
    }
}

#[derive(Debug)]
pub(crate) struct ParticipateMultiPartyPayjoinOutcome {
    /// Time left on the payment obligation
    time_left: i32,
    /// Amount of the payment obligation
    amount_handled: f64,
}

impl ParticipateMultiPartyPayjoinOutcome {
    fn score(&self, multi_party_payjoin_utility_factor: f64) -> ActionScore {
        // TODO: score the participation as a linear function of the progression of the session
        let score = self.amount_handled * 100.0;
        debug!("ParticipateMultiPartyPayjoinEvent score: {:?}", score);
        ActionScore(score)
    }
}

/// State of the wallet that can be used to potential enumerate actions
#[derive(Debug)]
pub(crate) struct WalletView {
    payment_obligations: Vec<PaymentObligationData>,
    payjoin_proposals: Vec<(MessageId, BulletinBoardId, PayjoinProposal)>,
    active_multi_party_payjoins: Vec<BulletinBoardId>,
    new_multi_party_payjoins: Vec<(BulletinBoardId, MessageId)>,
    current_timestep: TimeStep,
    wallet_id: WalletId,
    // TODO: utxos, feerate, cospend oppurtunities, etc.
}

impl WalletView {
    pub(crate) fn new(
        payment_obligations: Vec<PaymentObligationData>,
        payjoin_proposals: Vec<(MessageId, BulletinBoardId, PayjoinProposal)>,
        new_multi_party_payjoins: Vec<(BulletinBoardId, MessageId)>,
        active_multi_party_payjoins: Vec<BulletinBoardId>,
        current_timestep: TimeStep,
        wallet_id: WalletId,
    ) -> Self {
        Self {
            payment_obligations,
            payjoin_proposals,
            active_multi_party_payjoins,
            new_multi_party_payjoins,
            current_timestep,
            wallet_id,
        }
    }
}
fn get_payment_obligation_handled_outcome(
    payment_obligation_id: &PaymentObligationId,
    sim: &Simulation,
    current_timestep: TimeStep,
) -> PaymentObligationHandledOutcome {
    let payment_obligation = payment_obligation_id.with(&sim).data();
    let deadline = payment_obligation.deadline;
    let balance_difference = payment_obligation
        .amount
        .to_float_in(bitcoin::Denomination::Satoshi)
        * -1.0;
    PaymentObligationHandledOutcome {
        amount_handled: payment_obligation
            .amount
            .to_float_in(bitcoin::Denomination::Satoshi),
        balance_difference,
        time_left: deadline.0 as i32 - current_timestep.0 as i32,
    }
}

fn simulate_one_action(wallet_handle: &WalletHandleMut, action: &Action) -> Vec<PredictedOutcome> {
    let wallet_view = wallet_handle.wallet_view();
    let mut events = vec![];
    let old_info = wallet_handle.info().clone();

    // Deep clone the simulation and run the action
    let wallet_id = wallet_handle.data().id;
    let mut sim = wallet_handle.sim.clone();
    let mut new_wallet_handle = wallet_handle.data().id.with_mut(&mut sim);
    new_wallet_handle.do_action(action);
    let new_wallet_handle = wallet_id.with(&sim);
    let new_info = new_wallet_handle.info();

    if let Action::UnilateralSpend(payment_obligation_id) = action {
        let payment_obligation = payment_obligation_id.with(&sim).data();
        let deadline = payment_obligation.deadline;
        let balance_difference = payment_obligation
            .amount
            .to_float_in(bitcoin::Denomination::Satoshi)
            * -1.0;
        events.push(PredictedOutcome::PaymentObligationsHandled(vec![
            PaymentObligationHandledOutcome {
                amount_handled: payment_obligation
                    .amount
                    .to_float_in(bitcoin::Denomination::Satoshi),
                balance_difference,
                time_left: deadline.0 as i32 - wallet_view.current_timestep.0 as i32,
            },
        ]));
    }

    if let Action::BatchSpend(payment_obligation_ids) = action {
        let mut outcomes = vec![];
        for payment_obligation_id in payment_obligation_ids.iter() {
            outcomes.push(get_payment_obligation_handled_outcome(
                payment_obligation_id,
                &sim,
                wallet_view.current_timestep,
            ));
        }
        events.push(PredictedOutcome::PaymentObligationsHandled(outcomes));
    }

    // Check if the wallet initiated a payjoin
    let old_initiated_payjoins = old_info.initiated_payjoins;
    let new_initiated_payjoins = new_info.initiated_payjoins.clone();
    if let Some((payment_obligation_id, _)) = new_initiated_payjoins
        .difference(old_initiated_payjoins)
        .into_iter()
        .next()
    {
        let po = payment_obligation_id.with(&sim).data();
        let amount_handled = po.amount.to_float_in(bitcoin::Denomination::Satoshi);
        let balance_difference = amount_handled * -1.0; // TODO: fee's are not factored in yet
        events.push(PredictedOutcome::InitiatePayjoin(InitiatePayjoinOutcome {
            time_left: po.deadline.0 as i32 - wallet_view.current_timestep.0 as i32,
            amount_handled,
            balance_difference,
            fee_savings: Amount::ZERO, // TODO: implement this
        }));
    }

    let old_received_payjoins = old_info.received_payjoins;
    let new_received_payjoins = new_info.received_payjoins.clone();
    if let Some((payment_obligation_id, _)) = new_received_payjoins
        .difference(old_received_payjoins)
        .into_iter()
        .next()
    {
        let po = payment_obligation_id.with(&sim).data();
        let amount_handled = po.amount.to_float_in(bitcoin::Denomination::Satoshi);
        let balance_difference = amount_handled * -1.0; // TODO: fee's are not factored in yet
        events.push(PredictedOutcome::RespondToPayjoin(
            RespondToPayjoinOutcome {
                amount_handled,
                balance_difference,
                fee_savings: Amount::ZERO, // TODO: implement this
            },
        ));
    }

    events
}

/// Strategies will pick one action to minimize their cost
/// TODO: Strategies should be composible. They should enform the action decision space scoring and doing actions should be handling by something else that has composed multiple strategies.
pub(crate) trait Strategy: std::fmt::Debug {
    fn enumerate_candidate_actions(&self, state: &WalletView) -> Vec<Action>;
    fn locked_inputs(&self, _state: &WalletView) -> Vec<Outpoint> {
        vec![]
    }
    fn clone_box(&self) -> Box<dyn Strategy>;
}

#[derive(Debug, PartialEq, PartialOrd)]
pub(crate) struct ActionScore(f64);

impl Sum for ActionScore {
    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {
        Self(iter.map(|s| s.0).sum())
    }
}

impl Eq for ActionScore {}

impl Ord for ActionScore {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        assert!(!self.0.is_nan() && !other.0.is_nan());
        self.0.partial_cmp(&other.0).expect("Checked for NaNs")
    }
}

impl Add for ActionScore {
    type Output = Self;
    fn add(self, other: Self) -> Self {
        Self(self.0 + other.0)
    }
}

#[derive(Debug, Clone)]
pub(crate) struct UnilateralSpender;

impl Strategy for UnilateralSpender {
    /// The decision space of the unilateral spender is the set of all payment obligations and payjoin proposals
    fn enumerate_candidate_actions(&self, state: &WalletView) -> Vec<Action> {
        if state.payment_obligations.is_empty() {
            return vec![Action::Wait];
        }
        let mut actions = vec![];
        for po in state.payment_obligations.iter() {
            // For every payment obligation, we can spend it unilaterally
            actions.push(Action::UnilateralSpend(po.id));
        }

        actions
    }

    fn clone_box(&self) -> Box<dyn Strategy> {
        Box::new(self.clone())
    }
}

#[derive(Debug, Clone)]
pub(crate) struct BatchSpender;

impl Strategy for BatchSpender {
    fn enumerate_candidate_actions(&self, state: &WalletView) -> Vec<Action> {
        if state.payment_obligations.is_empty() {
            return vec![Action::Wait];
        }
        // TODO: we may need to consider differnt partitioning strategies for the batch spend
        // Maybe some partitions have higher utility if batched than others that have longer deadlines
        let mut payment_obligation_ids: Vec<PaymentObligationId> = vec![];
        for po in state.payment_obligations.iter() {
            payment_obligation_ids.push(po.id);
        }
        vec![Action::BatchSpend(payment_obligation_ids)]
    }

    fn clone_box(&self) -> Box<dyn Strategy> {
        Box::new(self.clone())
    }
}

#[derive(Debug, Clone)]
pub(crate) struct PayjoinStrategy;

impl Strategy for PayjoinStrategy {
    fn enumerate_candidate_actions(&self, state: &WalletView) -> Vec<Action> {
        if state.payment_obligations.is_empty() {
            return vec![Action::Wait];
        }
        let mut actions = vec![];
        for po in state.payment_obligations.iter() {
            // TODO: some payment obligations may not be suitable for payjoin. i.e if the receiver opts out
            actions.push(Action::InitiatePayjoin(po.id));
        }

        // Check for messages from other wallets
        for (message_id, bulletin_board_id, payjoin_proposal) in state.payjoin_proposals.iter() {
            // We should evaluate responding using all payment obligations that have not been handled
            for po in state.payment_obligations.iter() {
                actions.push(Action::RespondToPayjoin(
                    payjoin_proposal.clone(),
                    po.id,
                    *bulletin_board_id,
                    *message_id,
                ));
            }
        }

        actions
    }

    fn clone_box(&self) -> Box<dyn Strategy> {
        Box::new(self.clone())
    }
}

#[derive(Debug, Clone)]
pub(crate) struct MultipartyPayjoinInitiatorStrategy;

impl Strategy for MultipartyPayjoinInitiatorStrategy {
    fn enumerate_candidate_actions(&self, state: &WalletView) -> Vec<Action> {
        if state.payment_obligations.is_empty() {
            return vec![Action::Wait];
        }
        // TODO: if the sesion is on going do not intiate a new one
        // TODO: this is scaffolding for now, peers in the future will evaluate if they should initiate a multi-party payjoin given the number of payment obligations
        if state.wallet_id != WalletId(0) {
            return vec![Action::Wait];
        }
        let receivers = state
            .payment_obligations
            .iter()
            .map(|po| po.to)
            .collect::<HashSet<_>>();
        if receivers.len() < 2 {
            return vec![Action::Wait];
        }

        // TODO: only one multi-party payjoin session can be active at a time FOR NOW
        let mut actions = vec![];
        if !state.active_multi_party_payjoins.is_empty() {
            // If we have an active session we should actively participate in it
            debug_assert!(state.active_multi_party_payjoins.len() <= 1);
            for bulletin_board_id in state.active_multi_party_payjoins.iter() {
                actions.push(Action::ContinueParticipateMultiPartyPayjoin(
                    *bulletin_board_id,
                ));
            }
            return actions;
        }

        actions.push(Action::InitiateMultiPartyPayjoin(
            state.payment_obligations.iter().map(|po| po.id).collect(),
        ));

        actions
    }

    fn clone_box(&self) -> Box<dyn Strategy> {
        Box::new(self.clone())
    }
}

#[derive(Debug, Clone)]
pub(crate) struct MultipartyPayjoinParticipantStrategy;

impl Strategy for MultipartyPayjoinParticipantStrategy {
    fn enumerate_candidate_actions(&self, state: &WalletView) -> Vec<Action> {
        if state.payment_obligations.is_empty() {
            return vec![Action::Wait];
        }

        let mut actions = vec![];
        //TODO: Only one multi-party payjoin session can be initiated at a time FOR NOW

        if let Some((bulletin_board_id, message_id)) = state.new_multi_party_payjoins.iter().next()
        {
            // TODO participate in one session at a time
            if state.active_multi_party_payjoins.is_empty() {
                for po in state.payment_obligations.iter() {
                    actions.push(Action::ParticipateMultiPartyPayjoin((
                        *message_id,
                        *bulletin_board_id,
                        po.id,
                    )));
                }
            }
        }

        // Or continue to participate in the existing session
        for bulletin_board_id in state.active_multi_party_payjoins.iter() {
            actions.push(Action::ContinueParticipateMultiPartyPayjoin(
                *bulletin_board_id,
            ));
        }
        actions
    }

    fn clone_box(&self) -> Box<dyn Strategy> {
        Box::new(self.clone())
    }
}

#[derive(Debug, Clone)]
pub(crate) struct CompositeStrategy {
    pub(crate) strategies: Vec<Box<dyn Strategy>>,
}

impl Strategy for CompositeStrategy {
    fn enumerate_candidate_actions(&self, state: &WalletView) -> Vec<Action> {
        let mut actions = vec![];
        for strategy in self.strategies.iter() {
            actions.extend(strategy.enumerate_candidate_actions(state));
        }
        actions
    }

    fn locked_inputs(&self, state: &WalletView) -> Vec<Outpoint> {
        self.strategies
            .iter()
            .flat_map(|s| s.locked_inputs(state))
            .collect()
    }

    fn clone_box(&self) -> Box<dyn Strategy> {
        Box::new(self.clone())
    }
}

impl Clone for Box<dyn Strategy> {
    fn clone(&self) -> Self {
        self.clone_box()
    }
}

// TODO: this should be a trait once we have different scoring strategies
#[derive(Debug, Clone, PartialEq)]
pub(crate) struct CompositeScorer {
    pub(crate) initiate_payjoin_utility_factor: f64,
    pub(crate) respond_to_payjoin_utility_factor: f64,
    pub(crate) payment_obligation_utility_factor: f64,
    pub(crate) multi_party_payjoin_utility_factor: f64,
}

impl CompositeScorer {
    pub(crate) fn score_action(
        &self,
        action: &Action,
        wallet_handle: &WalletHandleMut,
    ) -> ActionScore {
        let events = simulate_one_action(wallet_handle, action);
        // For now each action should only result in one event or none if we are waiting
        // TODO: wallets should evaluate waiting and score it high if they are expecting payments from payjoin compatible wallets
        debug_assert!(events.len() <= 1);
        let mut score = ActionScore(0.0);
        for event in events {
            match event {
                PredictedOutcome::PaymentObligationsHandled(outcomes) => {
                    for outcome in outcomes.iter() {
                        score = score + outcome.score(self.payment_obligation_utility_factor);
                    }
                }
                PredictedOutcome::InitiatePayjoin(event) => {
                    score = score + event.score(self.initiate_payjoin_utility_factor);
                }
                PredictedOutcome::RespondToPayjoin(event) => {
                    score = score + event.score(self.respond_to_payjoin_utility_factor);
                }
                PredictedOutcome::InitiateMultiPartyPayjoin(event) => {
                    score = score + event.score(self.multi_party_payjoin_utility_factor);
                }
                PredictedOutcome::ParticipateMultiPartyPayjoin(event) => {
                    score = score + event.score(self.multi_party_payjoin_utility_factor);
                }
            }
        }
        score
    }
}

/// Creates a strategy instance from its name string
pub(crate) fn create_strategy(name: &str) -> Result<Box<dyn Strategy>, String> {
    match name {
        "UnilateralSpender" => Ok(Box::new(UnilateralSpender)),
        "BatchSpender" => Ok(Box::new(BatchSpender)),
        "PayjoinStrategy" => Ok(Box::new(PayjoinStrategy)),
        "MultipartyPayjoinInitiatorStrategy" => Ok(Box::new(MultipartyPayjoinInitiatorStrategy)),
        "MultipartyPayjoinParticipantStrategy" => {
            Ok(Box::new(MultipartyPayjoinParticipantStrategy))
        }
        _ => Err(format!("Unknown strategy: {}", name)),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{message::PayjoinProposal, wallet::PaymentObligationData, TimeStep};
    use bitcoin::Amount;

    // Helper to create a minimal WalletView for testing
    fn create_test_wallet_view(
        payment_obligations: Vec<PaymentObligationData>,
        payjoin_proposals: Vec<(MessageId, BulletinBoardId, PayjoinProposal)>,
    ) -> WalletView {
        WalletView::new(
            payment_obligations,
            payjoin_proposals,
            vec![],
            vec![],
            TimeStep(0),
            WalletId(0),
        )
    }

    #[test]
    fn test_unilateral_spender() {
        let strategy = UnilateralSpender;
        let po = PaymentObligationData {
            id: PaymentObligationId(0),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(1000),
            from: WalletId(0),
            to: WalletId(1),
        };
        let view = create_test_wallet_view(vec![po], vec![]);

        let actions = strategy.enumerate_candidate_actions(&view);

        assert_eq!(actions.len(), 1);
        assert!(actions
            .iter()
            .any(|a| matches!(a, Action::UnilateralSpend(_))));
    }

    #[test]
    fn test_batch_spender_creates_batches() {
        let strategy = BatchSpender;
        let po1 = PaymentObligationData {
            id: PaymentObligationId(0),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(1000),
            from: WalletId(0),
            to: WalletId(1),
        };
        let po2 = PaymentObligationData {
            id: PaymentObligationId(1),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(2000),
            from: WalletId(0),
            to: WalletId(2),
        };
        let view = create_test_wallet_view(vec![po1, po2], vec![]);

        let actions = strategy.enumerate_candidate_actions(&view);

        // BatchSpender creates a single batch with all obligations
        assert_eq!(actions.len(), 1);
        assert!(actions
            .iter()
            .any(|a| matches!(a, Action::BatchSpend(ids) if ids.len() == 2)));
    }

    #[test]
    fn test_payjoin_strategy() {
        let strategy = PayjoinStrategy;
        let po = PaymentObligationData {
            id: PaymentObligationId(0),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(1000),
            from: WalletId(0),
            to: WalletId(1),
        };

        // Test without proposals should only return InitiatePayjoin
        let view = create_test_wallet_view(vec![po.clone()], vec![]);
        let actions = strategy.enumerate_candidate_actions(&view);

        assert_eq!(actions.len(), 1);
        assert!(actions
            .iter()
            .any(|a| matches!(a, Action::InitiatePayjoin(_))));

        // Test with proposals should return both InitiatePayjoin and RespondToPayjoin
        let proposal = PayjoinProposal {
            tx: crate::transaction::TxData {
                inputs: vec![],
                outputs: vec![],
                wallet_acks: vec![],
            },
            valid_till: TimeStep(200),
        };

        let view =
            create_test_wallet_view(vec![po], vec![(MessageId(0), BulletinBoardId(0), proposal)]);

        let actions = strategy.enumerate_candidate_actions(&view);

        assert_eq!(actions.len(), 2);
        assert!(actions
            .iter()
            .any(|a| matches!(a, Action::InitiatePayjoin(_))));
        assert!(actions
            .iter()
            .any(|a| matches!(a, Action::RespondToPayjoin(_, _, _, _))));
    }

    #[test]
    fn test_composite_strategy_combines_actions() {
        let composite = CompositeStrategy {
            strategies: vec![Box::new(UnilateralSpender), Box::new(BatchSpender)],
        };

        let po1 = PaymentObligationData {
            id: PaymentObligationId(0),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(1000),
            from: WalletId(0),
            to: WalletId(1),
        };
        let po2 = PaymentObligationData {
            id: PaymentObligationId(1),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(2000),
            from: WalletId(0),
            to: WalletId(2),
        };
        let view = create_test_wallet_view(vec![po1, po2], vec![]);

        let actions = composite.enumerate_candidate_actions(&view);

        // Should include actions from both strategies
        // UnilateralSpender: 2 actions (one per obligation)
        // BatchSpender: 1 action (batch of both)
        assert_eq!(actions.len(), 3);

        let unilateral_count = actions
            .iter()
            .filter(|a| matches!(a, Action::UnilateralSpend(_)))
            .count();
        assert_eq!(unilateral_count, 2);

        let batch_count = actions
            .iter()
            .filter(|a| matches!(a, Action::BatchSpend(_)))
            .count();
        assert_eq!(batch_count, 1);
    }

    #[test]
    fn test_multiparty_initiator_with_insufficient_receivers() {
        let strategy = MultipartyPayjoinInitiatorStrategy;

        // Only 1 unique receiver - not enough for multi-party
        let po1 = PaymentObligationData {
            id: PaymentObligationId(0),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(1000),
            from: WalletId(0),
            to: WalletId(1), // Same receiver
        };
        let po2 = PaymentObligationData {
            id: PaymentObligationId(1),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(2000),
            from: WalletId(0),
            to: WalletId(1), // Same receiver
        };
        let view = create_test_wallet_view(vec![po1, po2], vec![]);

        let actions = strategy.enumerate_candidate_actions(&view);

        // Should return Wait because we need at least 2 different receivers
        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], Action::Wait));
    }

    #[test]
    fn test_multiparty_initiator_with_multiple_receivers() {
        let strategy = MultipartyPayjoinInitiatorStrategy;

        // 2 different receivers - enough for multi-party
        let po1 = PaymentObligationData {
            id: PaymentObligationId(0),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(1000),
            from: WalletId(0),
            to: WalletId(1), // Receiver 1
        };
        let po2 = PaymentObligationData {
            id: PaymentObligationId(1),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(2000),
            from: WalletId(0),
            to: WalletId(2), // Receiver 2 (different)
        };
        let view = create_test_wallet_view(vec![po1, po2], vec![]);

        let actions = strategy.enumerate_candidate_actions(&view);

        assert_eq!(actions.len(), 1);
        assert!(actions
            .iter()
            .any(|a| matches!(a, Action::InitiateMultiPartyPayjoin(ids) if ids.len() == 2)));
    }

    #[test]
    fn test_multiparty_initiator_only_wallet_0() {
        let strategy = MultipartyPayjoinInitiatorStrategy;

        let po = PaymentObligationData {
            id: PaymentObligationId(0),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(1000),
            from: WalletId(1), // Not wallet 0
            to: WalletId(2),
        };

        // Create view with wallet_id = 1 (not 0)
        let view = WalletView::new(
            vec![po],
            vec![],
            vec![],
            vec![],
            TimeStep(0),
            WalletId(1), // Wallet 1, not 0
        );

        let actions = strategy.enumerate_candidate_actions(&view);

        // Should return Wait because only Wallet 0 can initiate
        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], Action::Wait));
    }

    #[test]
    fn test_multiparty_participant_with_new_invitation() {
        let strategy = MultipartyPayjoinParticipantStrategy;

        let po = PaymentObligationData {
            id: PaymentObligationId(0),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(1000),
            from: WalletId(0),
            to: WalletId(1),
        };

        // Create view with a new multi-party payjoin invitation
        let view = WalletView::new(
            vec![po],
            vec![],
            vec![(BulletinBoardId(0), MessageId(0))], // New invitation
            vec![],                                   // No active sessions yet
            TimeStep(0),
            WalletId(1),
        );

        let actions = strategy.enumerate_candidate_actions(&view);

        assert_eq!(actions.len(), 1);
        assert!(actions
            .iter()
            .any(|a| matches!(a, Action::ParticipateMultiPartyPayjoin(_))));
    }

    #[test]
    fn test_multiparty_participant_with_active_session() {
        let strategy = MultipartyPayjoinParticipantStrategy;

        let po = PaymentObligationData {
            id: PaymentObligationId(0),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(1000),
            from: WalletId(0),
            to: WalletId(1),
        };

        // Create view with an active session
        let view = WalletView::new(
            vec![po],
            vec![],
            vec![],
            vec![BulletinBoardId(0)], // Active session
            TimeStep(0),
            WalletId(1),
        );

        let actions = strategy.enumerate_candidate_actions(&view);

        assert_eq!(actions.len(), 1);
        assert!(actions
            .iter()
            .any(|a| matches!(a, Action::ContinueParticipateMultiPartyPayjoin(_))));
    }

    #[test]
    fn test_multiparty_participant_prefers_continue_when_invite_and_active() {
        let strategy = MultipartyPayjoinParticipantStrategy;

        let po = PaymentObligationData {
            id: PaymentObligationId(0),
            deadline: TimeStep(100),
            reveal_time: TimeStep(0),
            amount: Amount::from_sat(1000),
            from: WalletId(0),
            to: WalletId(1),
        };

        // With both a new invitation and active session, strategy should continue active session.
        let view = WalletView::new(
            vec![po],
            vec![],
            vec![(BulletinBoardId(0), MessageId(0))],
            vec![BulletinBoardId(1)],
            TimeStep(0),
            WalletId(1),
        );

        let actions = strategy.enumerate_candidate_actions(&view);

        assert_eq!(actions.len(), 1);
        assert!(matches!(
            actions[0],
            Action::ContinueParticipateMultiPartyPayjoin(BulletinBoardId(1))
        ));
    }
}
